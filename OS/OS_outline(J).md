## 운영체제의 개요
> 컴퓨터 HW바로 위에 설치되어 사용자 및 다른 SW와 하드웨어를 연결하는 SW

![image-20220124174028087](C:\Users\sw133\AppData\Roaming\Typora\typora-user-images\image-20220124174028087.png)

* #### 목적

  > 컴퓨터 시스템을 **편리**하게 사용할 수 있는 환경을 제공

  * 자원을 효율적으로 관리

    * CPU, 메모리, I/O 장치(컴퓨터 리소스)등을 관리

      주어진 자원으로 최대한 성능 ==> **효율성**

      특정 사용자/프로그램의 지나친 불이익이 발생 하지 않도록 ==> **형평성**

      사용자 및 운영체제 자신의 보호

      

  * 편리하게 사용할 수 있는 환경을 제공

    * ex) 멀티 태스킹, HW를 직접다루는 부분은 OS가 대행

작은 의미의 운영체제 : 커널 (OS의 핵심부분 메모리에 상주하는 부분)

큰 의미의 운영체제 : 커널 뿐만아니라 각종 유틸리티(프로세스)를 포함한 개념



* ### 컴퓨터의 기본적인 구조

  

![image-20220124180943013](C:\Users\sw133\AppData\Roaming\Typora\typora-user-images\image-20220124180943013.png)!

![image-20220128235625785](C:\Users\sw133\AppData\Roaming\Typora\typora-user-images\image-20220128235625785.png)

디바이스 컨트롤러(일종의 작은 cpu)



로컬 버퍼 (일종의 작은 메모리)



모드비트 (os가 cpu를 사용하고있는지 여부를 체크하는부분)

​	1-(사용자 모드) 사용자 프로그램 0-(모니터 모드) os 특권명령은 모드비트가 0인 모니터(or 커널모드, 시스템 모드) 상태에서만

인터럽트나 예외 발생시 모드비트가 0으로 바뀜

사용자 프로그램에 cpu를 주기전에 모드비트를 1로 바꾸고 줌



cpu가 다른 컨트롤러들에게 명령을 하고 콘트롤러들은 일을 다하면 인터럽트를 검



레지스터 : 

PC(프로그램 카운터):메모리의 주소

PC가 os를 가르키고있으면 모드비트는 0

사용자 프로그램을 사용하고 있으면 1

OS는 다른 CPU가 사용하고있으면 cpu점유권을 뺏어올수 없음

그래서 timer라는 장치를 사용 (일정시간이 지나면 인터럽트를 걸어 모드비트를 0으로 바꾸는 방식으로)

그떄 레지스터가 사용자프로그램을 가르치다 OS를 가르키는 점프가 필요함



정해진 시간이 흐른뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴



모든 IO()는 특권명령이고 사용자 프로그램이 사용하기위해선 OS에 요청해야함 이 요청이 시스템 콜

이때 사용자프로그램이 스스로 인터럽트 신호를 보냄 (소프트 웨어 인터럽트)



콘트롤러 타이머(하드웨어 인터럽트) 일반적으로 얘기하는 인터럽트는 하드웨어 인터럽트임



cpu는 기계어를 실행시킨뒤 매번 인터럽트 라인을 통해 인터럽트가 있는지 체크



메모리 cpu의 작업공간



인터럽트라인: 인터럽트가 쌓이는 곳

### 인터럽트

* 인터럽트
  * 인터럽트(하드웨어 인터럽트) : 하드웨어(컨트롤러나 타이머)가 발생시키는 인터럽트
  * 트랩(소프트웨어 인터럽트):프로그램이 발생시키는 인터럽트
    * Exception : 프로그램이 오류를 범한 경우
    * System call : 프로그램이 커널함수를  호출하기 위해 보내는 요청
* 용어
  * 인터럽트 벡터
    * 해당 인터럽트의 처리 루틴 주소를 가지고 있음
  * 인터럽트 처리 루틴 = 인터럽트 핸들러
    * 해당 인터럽트를 처리하는 커널 함수



### 디바이스 컨트롤러

* 디바이스 컨트롤러

  * IO유형의 장치를 관리하는 일종의 작은cpu
  * 제어정보를 위해 control register, status register를 가짐
  * local buffer를 가짐 (일종의 데이터 레지스터혹은 일종의 작은 메모리)
  * 버퍼가 있는 이유는 컨트롤러가 직업 메모리에 데이터를 주는행위가 금지되어있기때문
  
  > IO는 실제로 device와 local buffer사이에서 일어남
  >
  > 디바이스 컨트롤러는 IO가 끝나면 인터럽트로 cpu에게 그 사실을 알림
  >
  > 디바이스 드라이버에서 실행되는 코드들을 보고 펌웨어 라고 부름
  
  * ㅁㄴㅇ
  * ㅁㄴㅇ

OS 시스템구조 마지막 28.00분까지 들음 



### 입출력

* 동기식 입출력

  > IO요청후 입출력 작업이 완됴된 후에야 제어가 사용자 프로그램에 넘어감

  * 구현방법1

    * IO가 끝날떄까지 cpu를 낭비시킴

    * 매시점 하나의 IO만 일어날 수 있음

      

  * 구현방법2

    * IO가 완료될떄까지 해당 프로그램에게서 CPU를 빼앗음

    * IO처리를 기다리는줄에 그 프로그램을 줄세움

    * 다른 프로그램에게 cpu 사용권을 줌

      

* 비동기식 입출력

  > IO가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

  두경우 모두 IO의 완료는 인터럽트로 알려줌

  

![image-20220129124759858](C:\Users\sw133\AppData\Roaming\Typora\typora-user-images\image-20220129124759858.png)





###  메모리 접근

* DMA(DIrect Memory Access)

  * DMA 컨트롤러 - 인터럽트가 자주발생하는것을 비효율적이라 생각해서 만들어진 모아둘 장소
  * 빠른 입출력 장치를 메모리에 가까운 속도로 처리가히 위해 사용
  * cpu 의 중재없이 디바이스 컨트롤러가 해당 버퍼의 내용을 메모리에 block단위로 직접 전송
  * 바이트단위가 아니라 block단위로 인터럽트 발생

  



![image-20220129125234250](C:\Users\sw133\AppData\Roaming\Typora\typora-user-images\image-20220129125234250.png)



### 입출력

![image-20220129191804505](C:\Users\sw133\AppData\Roaming\Typora\typora-user-images\image-20220129191804505.png)





### 주요 단어

* CPU 스케줄링
* 메모릭 관리
* 인터럽트
* 캐싱
* 디스크 스케줄링
* 파일 관리
* 입출력 관리
* 네트워크
* 인터프리터
* 인터럽트



### 프로세스의 상태

 



### 분류

* 동시 작업 가능 여부

  * 단일 작업 single tasking - 한 번에 하나의 작업만 처리

    한 명령을 전부 수행하기 전까지 다른작업 불가.

  * 다중 작업 multi tasking - 동시에 두 개 이상의 작업 처리

    

* 사용자의 수

  * 단일 사용자 single user - 

  * 다중 사용자 multi user - 

    

* 처리방식 

  * 일괄 처리 batch processing

    작업 요청의 일정량 모아서 한꺼번에 처리

    작업이 완전 종료될 때까지 기다려야함.

    

  * 시분할 time sharing

    여러 작업을 수행할  때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용

    일괄 처리 시스템에 비해 짧은 응답 시간을 가짐

    

  * 실시간 realtime 

    정해진 시간 안에(dead line) 어떠한 일이 반드시 종료됨의 보장이 되어야하는 시스템

    ex) 미사일 제어, 공장 제어, 등등

    확장개념 

    * 경성(hard)
    * 연성(soft)



### 용어

* 멀티 태스킹 - 여러 작업을 동시에 처리

* 멀티 프로그래밍 - 여러 프로그램이 메모리에 적재됨을 의미

* 시분할 - cpu를 시간단위로 분할해 사용한다는 의미

* 멀티 프로세스 - 하나의 컴퓨터에 여러개의 cpu(프로세서)가 붙어 있음을 의미

  

### 예시

* 유닉스 

  * 코드의 대부분이 c언어

  * 높은 이식성

  * 최소한의 커널 구조

  * 확장 용이

  * 소스코드 공개

  * 개발에 용이

  * 다양한 버전, 베포판

    

* DOS

  * 단일 사용자용

    

* Windows

  * GUI 기반
  * 다중 작업용
  * 풍부한 소프트웨어 지원
  * plug and play, 네트워크 환경 강화
  * 불안정성
  * dos app 호환성 제공



* 





