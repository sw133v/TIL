## 메모리 관리

종류

* Logical address (virtual memory)

  * 프로세스 마다 독립적으로 가지는 주소공간
  * 각 프로세스마다 0번지부터 시작
  * cpu가 보여주는 주소 (cpu는 물리적인 주소를 안봄)

  

* Physical address

  * 메모리에 실제 올라가는 위치



주소 바인딩 : 주소를 결정하는 것

Symbolic -> Logical -> Physical

(소스 코드)  (실행 파일)  (물리적 메모리)



### 주소 바인딩

* Compile time binding
  * 물리적 메모리 주소가 컴파일 시 알려짐
  * 시작 위치 변경시 재 컴파일
  * 컴파일러는 절대 코드(absolute code)를 생성
  * 논리적 주소, 물리적 주소 같을때 



* Load time binding
  * Loader의 책임하에 물리적 메모리 주소 부여
  * 컴파일러가 재비치 가능 코드(relocatable code)를 생성한 경우 가능



* Run time binding = Execution time binding
  * 수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음 -> 그래서 cpu가 주소 참조할때마다 점검 해야함
  * CPU가 주소를 참조할 때마다 binding을 점검 (adderess mapping table)
  * 하드웨어적인 지원이 필요(MMU)



### MMU (Memory-Management Unit)

> 논리적 주소를 물리적 주소로 매핑해주는 HW Device

* MMU 스키마

#### 구조 

![image-20220219191626969](C:\Users\sw133\ssafy7\TIL\OS\DeadLock\image-20220219191626969.png)

  

### 용어

* Dynamic Loading

  > 프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것

  * memory utiliztion의 향상
  * 가끔씩 사용되는 많은 양의 코드의 경우 유용 ex) 오류 처리 루틴
  * 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능(OS는 라이브러리를 통해 지원가능)

  loading : 메모리에 올리는것

  우리가 쓰는 방식은 아님 왜냐면 OS를 통해서 하는 것 이기 때문

  

* Dynamic Linking (<- static 라이브러리)

  > Linking(소스코드와 라이브러리가 연결되는)을 실행 시간까지 미루는 기법

  * Static linking (대부분의 링크의 개념)
    * 라이브러리가 프로그램의 실행 파일 코드에 포함된 개념
    * 실행파일의 크기가 커짐
    * 동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비
    
  * Dynamic linking (<-shared 라이브러리)
    * 라이브러리가 실행시 연결(link)됨
    
    * 라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기위한 stub이라는 작은 코드를 둠
    
    * 라이브러리가 이미 메모리에 있으면 그 루틴의 주로소 가고 없으면 디스크에서 읽어옴
    
    * 운영체제의 도움이 필요
    
      

리눅스 에서는 .so (shared object)

윈도우 에서는 .dll 형식으로 존재



* Overlays

  > Dynamic Loading과 비슷함 구분 필요

  * 메모리에 프로세스의 부분중 실제 필요한 정보만을 올림
  * 프로세스의 크기가 메모리 보다 클 때 유용
  * 프로그래머가 수작업으로 구현하는것



* Swapping

  > 프로세스를 일시적으로 메모리에서 backing store(=swap area 보조 기억장치)로 쫒아내는 것
  >
  > 통째로 쫓아내는 개념

  swap in/ swwap out

  * 일반적으로 중기 스케줄러(swapper)에 의해 swap out 시킬 프로세스 선정
  * priority-based CPU 스케줄링 알고리즘
    * 우선순위가 낮은 프로세스를 swapped out
    * 우선순위가 높은 프로세스를 메모리에 load
  * compile time 혹은 load time binding에서는 원래 메모리 위치로 swap in해야함
  * Execution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음
  * swap time은 대부분 transfer time(swap되는 양에 비례하는시간)임



### 물리적 메모리 관리 기법

> 메모리는 일반적으로 두 영역으로 나뉘어 사용
>
> OS 상주 영역 - 인터럽트 벡터와 낮은 주소 영역 사용
>
> 사용자 프로세스 영역 - 높은 주소 영역 사용

#### Contiguouns allocation(연속 할당)

* Fixed partition(고정 분할 방식)
  * ㄴ



* (가변 분할 방식)
  * ㄴ



* External fragmentation (외부 조각)
  * 프로그램 크기보다 분할의 크기가 작은 경우
  * 아무 프로그램에도 배정되지 않는 빈 곳인데도 프로그램이 올라갈 수 없는 작은 분할
  
* Internal fragmentation (내부 조각)
  * 프로그램 크기보다
  
  
  
* Hole
  * 가용 메모리 공간
  * 다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음
  * 프로세스가 도착하면 수용 가능한 hole을 할당
  * 운영체제는 다음의 정보를 유지
    1. 할당 공간
    2. 가용 공간



방식

* First-fit
  * size가 n이상인 것 중 최초로 찾아지는 hole에 할당
* best-fit
  * Size가 n이상인 가장 작은 hole을 찾아서 할당
  * hole들의 리스트가 크기순으로 정렬되지않은 경우 모든 리스트를 탐색 해야함 -> 오버헤드 발생
  * 많은 수 의 아주 작은 hole들이 생성됨
* Worst-fit
  * 가장 큰 hole에 할당
  * 역시 모든 리스트를 탐색
  * 상대적으로 아주 큰 hole들이 생성됨

first-fit, best-fit > worst-fit

* Compaction
  * 사용 중인 메모리 영역을 한군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는것
  * 매우 비용이 많이듦
  * 최소한의 메모리 이동으로 compaction하는 방법(복잡함)
  * 해당 방법은 프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행 가능