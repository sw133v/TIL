## 가상 메모리

> * 하나의 프로세스 전체가 한번에 주기억장치(memory)에 존재하지 않고 일부만 있어도 수행하게 하는 기법
>
> * 가상 메모리를 사용하면 실제 주소 공간의 크기보다 큰 가상 주소 공간상에서 프로그래밍 뿐 만아니라
>
>   프로세스가 메모리 크기보다 커도 프로세스를 수행할 수 있다.

### 동적 주소 변환(Dynamic Address Translation)

* 주소 사상 기법 : 가상 주소 -> 실제 주소
* 동적 주소 변환(DAT) 기법 : 프로세스가 수행될 때 가상 주소를 실제 주소로 변환하는 매커니즘
* 가상기억 주소에 대한 실제 메모리내의 존재여부, 존재시 메모리 위치를 나타내기 위한 **대응 관계 테이블**을 유지 및 관리



### 블록 사상(Block Mapping)

> Block : 가상 메모리에 대한 분할 단위(블록의 크기, 같은 크기(page) or 다른 크기(segment)등)
>
> 구조 : 블록번호 b, 변위 d -> 가상 주소 v = (b, d)

* 블록 사상 시스템에서의 가상 주소 양식

* 항목별로 사상시키는 것은 비효율적이기 때문에 사상 항목을 블록단위로 묶어서 여러 가상 메모리의 블록이 위치하는 장소만 시스템이 추적하도록 함.

| block 이 클때                                                | block 이 작을때                                |
| ------------------------------------------------------------ | ---------------------------------------------- |
| 기억 장치(주, 보조 둘다 해당하는듯?)의 오버헤드는 감소       | 기억장치의  오버헤드의 증가                    |
| 주기억 장치(memory)와 보조기억 장치(storage)간의 데이턴 전송 시간이 많아짐 | memory 와 storage간의 데이터 전송시간이 줄어듦 |
| 실기억 공간의 낭비, 주기억 장치를 공유하는 프로세스의 수에 제한 |                                                |

* 블록을 같은 크기로 구성할 때 **page** 라고 하고 page와 관련된 가상 메모리 구성을 **paging**이라고 한다
* 블록을 서로 다른 크기로 구성할때 **segment** 라고 하고 segment 와 관련된 가상 메모리 구성을 segmentation 이라고 한다.
* 여러 크기의 segment를 다시 page 단위로 재구성하는 방식으로도 씀(paged segmentation 인듯?)

#### 주소변환

> 블럭 사상 테이블 시작점 레지스터는 블럭 사상 테이블의 시작주소를 가진다.



#### Paging(페이징)

> 구조 : 페이지 번호 p, 변위 d -> v = (p, d)

page mapping table에서 p를 찾고 page p가 페이지 프레임 번호 p'가 있을을 알아낸후, p' 와 d를 더하여 memory상 실제주소 r을 구함

##### direct mapping(직접 사상)



##### associative mapping(연관 사상)

> 연관 기억장치에 페이지 사상 테이블 전체를 넣는 방법

* 내용 주소화 기억장치(Content-addressable Memory / CAM)



##### 연관/직접 사상

> 적당한 비용을 캐시나 연관기억장치 기법에 의한 상점을 살리는 절충

* 가장 최근에 참조된 페이지는 조만간 다시 사용되기 쉽다는것을 이용 -> 연관기억장치에 페이지 사상 테이블 전체항목중 최근 참조된 일부 페이지들만 수용



##### 페이징 시스템의 공유

> 공유가 가능한 페이지를 가능한 한 최대로 공유(메모리 낭비 제거)



##### 페이지 크기

* 고려되야할 내용

  * 테이블 단편화(table gragmentation) : 페이지 크기가 작을수록 보다 많은 페이지 프레임 존재 -> 테이블 테이블 크기 증가

    -> 기억 공간 낭비

  * 페이지 크기가 작을수록 프로세스의 작업세트(woking set)을 확보하는데 도움이 됨.

    프로세스들은 구역서을 가지며 이 구역 내에서는 비교적 소량의 정보만을 필요로함

  * 실제로 프로시져 나 데이터 블럭의 단위는 대부분 페이지 크기의 정수배가 아니므로 단편화 현상 초래.

    마지막 페이지의 상태가 거의 빈상태, 거의 차있는 상태일수도 있기때문에 평균적으로 1/2페이지의 단편화가 생김

    따라서 페이지의 크기가 작을수록 내부의 다편화는 감소된다.

  * 페이지가 크면 참조하지 않을 정보들까지 memory에 올라가지 때문에 memory의 낭비를 초래

  * 디스크로부터의 입출력 전송은 많은 시간을 소비 -> 즉 입출력 전송 횟수를 줄이는 것에는 페이지 크기가 큰것이 이득

##### 페이지 인출 기법

* demand paging (요구 페이징)기법

  * 실행 중인 프로세스에 의해 명백히 참조되는 페이지만 storage에서 memory로 load

  * 프로세스가 새로운 페이지가 필여할 때마다 한번에 하나씩 그 페이지를 적재시켜야 함

    -> 즉 새로운 페이지가 적재될 때마다 그 프로세스는 그 페이지가 memory로 load될때 까지 대기해야함(낭비됨)

* anticaipatory paging(예상 페이징)기법

  * 프로세스가 필요할 페이지를 OS가 예측해서 memory에 여유가 있을때 페이지를 미리 적재
  * 예측 결정이 옳았으면 실행시간 많이 감소 -> 효율적으로 좋다!



##### page release(페이지 양도)

* 더 이상 필요로 하지 않는 특정 페이지가 존재하면 working set 으로 부터 제외해 page frame을 유용하게 만듦
* 컴파일러나 OS가 자동으로 페이지 제거를 질행해 working set 확보



#### Segmentation(세그먼테이션)

> 구조 세그먼트 번호 s, 변위 d -> v = (s, d)

##### direct mapping(직접 사상)



### 알고리즘

#### 페이지 교체 알고리즘

> 새로이 적재될 페이지를 위한 주기억 장치 공간확보를 위해 memory를 차지하고 있는 page중 어떤 페이지를 선택해 가상 공간으로 보낼것 인가 결정하는 기법

##### FIFO(First-In First-Out) 알고리즘

* 장점 : 빠른 설계, 이해하기 쉬움
* 단점 : 오랫동안 계속 쓰이는 페이지가 가장 오래됬다는 이유로 교체 되어야함

##### Optimal Replacement 알고리즘

* 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체
* 최적 교체 알고리즘
* 페이지 호출 순서에 대한 모든 상황을 사전에 미리 파악하고 있어야함 -> 비현실적

##### LRU(Least Recently Used)알고리즘

* 현시점에서 가장 오래전에 사용된 페이지를 제거
* 타임-스탬프용 카운터 및 스택을 두어 구분

##### second chance(2차 기회) 알고리즘

* 페이지 테이블의 각 항복에 참조 비트를 연관시킨후 참조되면 비트값을 1로 바꿈
* 교체를 할때 참조비트를 참고해서 0이면 교체, 1이면 그페이지에 기회를 줌(참조 비트를 0으로 변경) 이후론 FIFO방식으로 진행

##### LFU(Least Frequently Used) 알고리즘

* 가장 적게 사용된 페이지 가 교체됨

* 처음에 자주 쓰이다가 나중에 안쓰이는 페이지가 메모리에 남게되는 모순이 있는데

  MFU(Most Frequently Used)에 의해 해결 

##### NUR(Not Used Recently) 알고리즘

* 최근에 사용되지 않은 페이지는 가까운 미래에 사용되지 않는 경향에 따라 페이지를 교체

* 각 페이지에 두 개의 HW비트를 첨가

  * 참조된 비트
  * 변형된 비트

* 페이지 교체시 참조 비트가 0인 페이지를, 모두 1이라면 변형 비트가 0인것을 순으로 교체

* 다중 사용자 환겨에서 가까운 시간 안에 모든 참조 비트가 1이되는 모순을

  주시적으로 모든 참조 비트를 0으로 세트 시키는 방법으로 해결



#### Thrashing

프로세스 수행시간보다 페이지 교체시간이 더 많아질때 처리 속도가 떨어지는 상태

> 일반적으로 프로세스는 실행을 위해 몇개의 페이지 프레임만을 할당
>
> 할당 받지 못하면 페이지 부재가 빈번히 발생해 프레임 안에 있는 사용중인 페이지가 교체되어야한는데
>
> 페이지 부재가 계속적으로 발생하면 프로세스 수행시간보다 페이지 교체시간이 더 많아짐

##### Locality(구역성)

프로세스가 기억장치내 모든 정보를 균일하게 참조x

-> 국부적인 부분을 집중적으로 참조

> 스래싱을 방지하기 위하여 한 프로세스가 효율적인 수행을 위하여 제공받아야할 프레임의 수를 알아야함
>
> working set기법

* temporal locality(시간 구역성)
  * 최근에 참조된 기억장소가 가까운 장래에도 계속 참조될 가능성이 높음을 의미
  * ex 순환(looping), 서브루틴, 스택, counting과 totaling에 사용되는 변수
* spatial locality(공간 구역성)
  * 하나의 기억장소가 참조되면 그 근처의 기억장소가 계속 참조되는 경향이 있음을 의미
  * ex 배열수행, 순차 코드의 실행, 프로그래머들이 관련된 변수들을 서로 근처에 선언하는 경향이 있는 경우

##### Working Set

> 프로세스에 의해 자주 참조되는 페이지들의 집합체

* 하나의 프로세스가 효율적으로 실행되기 위해서 그 프로세스의 working set이 memory에 존재 해야함

  아니라면 스래싱이 발생할 수 있음

* 새로운 프로세스를 현재의 working set에 첨가시키는 결정은 새프로세스를 위한 working set을 수용할 만한 실기억 공간의 여유가 있는가에 달려있음

* 처음 시작되는 프로세스인 경우 시스템이 그 프로세스의 working set의 크기를 알 수 없으므로 대충 짐작하여 책정

* working set은 프로세스가 수행되는 동안 때로는 페이지들이 삭제되기도 하고 추가 되기도 할 뿐만 아니라

  프로세스가 거의 다른 working set으로의 전이가 일어난 경우에는 많은 변화가 발생

##### 페이지 부재율(PFF - Page-Fault Frequency)

페이지 부재율의 상한과 하한을 정해놓고 페이지 부재율이 상한을 넘으면 그 프로세스에게 다른 프레임을 더 할당해주고

하한 보다 낮으면 그 프로세스로부터 프레임을 회수 -> 이렇게 함으로서 직접적으로 스레싱을 방지 하면서 페이지 부재율을 측정하고 조절



