# 운영체제 면접 예상 질문

> 2022-03-09 수요일에 최종 질문들을 [OS 면접 예상질문 및 키워드 정리.md](OS 면접 예상질문 및 키워드 정리.md)  분류하고 자신에게 맞는 최적 답안을 완성합니다.
>
> 또한 단원마다 필요한 키워드를 취합하여 2학기 면접에서 바로 사용할 수 있는 자료로 갈무리합니다.

​          

## < 중간 범위 >

> 중간범위의 질문들.

### 운영체제에 대해 간략하게 설명해주세요

* 양요셉: 운영체제는 하드웨어 바로 위에 설치되는 소프트웨어 계층으로 하드웨어의 자원을 효율적으로 관리하는 역할을 합니다.
* 이미현: 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 프로그램의 모임입니다.

* 정성우: 컴퓨터 자원의 관리 및 ui제공등 사용자에게 편의성을 제공하기위한 SW 입니다

​         

### 운영체제의 목적에 대해 설명하시오

* 양요셉: 운영체제의 목적은 하드웨어의 자원을 효율적으로 관리하는 것입니다. 주어진 자원을 효율적으로 관리하 자원을 프로그램들에 형평성있게 배분해야합니다.
* 이미현: 컴퓨터 시스템을 편하게 제공할 수 있는 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리합니다.

​         

### DMA란 무엇인가

- 이주형

  > - 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
  > - CPU의 중재 없이 device contrioller가 device의 buffer storage의 내용을 **메모리에 block 단위로 직접 전송**
  > - 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴 -> 효율적

​       

### OS의 분류

- 이주형

  > - 동시 작업 가능 여부
  >   - 단일 작업(single tasking): 한 번에 하나의 작업만 정리
  >   - 다중 작업(multi tasking): 동시에 두 개 이상의 작업 정리
  > - 사용자의 수
  >   - 단일 사용자: MS-DOS, MS Windows
  >   - 다중 사용자: UNIX, NT server
  > - 처리 방식
  >   - 일괄 처리(batch processing): 작업 요청의 일정량을 모아 한꺼번에 정리
  >   - 시분할(time sharing): 컴퓨터 처리 능력을 일정한 시간 단위로 분할해 사용
  >     - 짧은 응답 시간, interactive한 방식
  >   - 실시간(Realtime): 정해진 시간 안에 어떤 일이 반드시 종료가 보장되어야 함
  >     - Hard realtime system(경성 실시간 시스템)
  >     - Soft realtime system(연성 실시간 시스템)

​        

### cpu가 입출력 기기에 접속하는 방식 중 하나인 memory mapped I/O란

- 이주형: 메모리와 I/O가 하나의 연속된 주소영역에 할당, I/O가 차지하는 만큼 메모리 용량은 감소하나 CPU입장에서는 메모리와 I/O가 동일한 외부기기로 간주되어 액세스하는 데 같은 신호를 사용, 메모리 명령어로 I/O까지 한번에 사용

* 정성우: 사용자가 보다 편하게 컴퓨터를 사용할 수 있게 컴퓨터 자원의 관리를 알아서 하고 UI를 제공하여 누구나 사용할 수 있게끔 하는데 목적이 있습니다.

​         

### blocked와 suspended는 어떤 점에서 다른가요?

* 양요셉: block은 CPU 사용을 효율적으로 하기 위해 프로세스가 I/O 작업을 처리해야하는 경우나 공유 자원에 접근할 때 큐 대기열에 넣어 프로세스를 대기하도록 하는 방식입니다. 반면 suspend는 메모리의 사용을 효율적으로 하기 위해 프로세스의 CPU사용 시간이 끝난 경우(타이머에 의한)나 Page fault에 의해 강제로 Swap Area로 이동시켜 프로세스의 수행 작업을 보관합니다. 
* 이미현: running, ready, blocked 모두 CPU 관점에서의 상태 분류일 뿐 실제로는 프로세스의 작업이 수행되고 있는 상태이지만, Suspended는 프로세스 수행 자체가 외부에 의해 정지된 상태라는 차이점이 있습니다. blocked 는 자신이 요청한 event 가 만족되면 ready 상태로 돌아오지만, suspended 는 누군가가 재개시켜줘야 다시 ready 상태로 돌아갈 수 있습니다.

* 정성우: 사용자나 특정 프로세스의 개입이 없이 자체적인 절차로 현재 명령어의 실행이 힘든 경우 메모리상 존재하며 기다리는 상태가 blocked이고 사용자나 특정 프로세스의 개입으로 pause를 하기 전까지 재게 할 수 없어 swap area에 올라가있는 상태가 suspended 상태입니다

​       

### 프로세서가 cpu에서 기계어 실행을 하다가 cpu를 내놓는 경우 3가지

- 이주형

  > - timer interrupt : 할당 시간 만료
  > - I/O or event wait : I/O나 오래 걸리는 작업 때문에 blocked로 가서 작업이 끝나면 interrupt로 다시 ready que로
  > - exit : 프로세스 종료

​        

### 부모 프로세스와 자식 프로세스가 실행될 때 자원은 어떻게 관리되나요?

* 양요셉: 부모 프로세스는 fork() 명령어를 통해 자기 자신을 복제하고 스스로 wait상태로 들어갑니다. 자식 프로세스의 PID값은 0으로 if문을 통해 부모 프로세스와 다른 코드를 실행하도록 하며 정상적으로 수행하는 경우 exit 명령어를 통해 부모프로세스를 깨웁니다. 자식 프로세스가 배정된 자원 이상을 요청한다면 부모 프로세스는 자식 프로세스를 종료합니다. 부모가 종료되거나 또는 사용자가 kill을 하는 경우 부모는 자식 프로세스를 차례 차례 종료하고 자기 자신을 종료합니다.
* 이미현: 부모 프로세스에서 fork() 에 의해 자식프로세스가 생성되어 실행되는 경우, 자식프로세스에는 부모 프로세스 주소공간의 복사본이 할당됩니다. PC와 같은 모든 정보를 복제하기 때문에 자식 프로세스는 부모프로세스와 동일한 문맥을 가지게 됩니다. 하지만 운영체제가 프로세스를 관리하기 위해 pid는 유일하게 다릅니다.

​           

### Multilevel Queue 에서 생길 수 있는 문제점, 해결방안

* 양요셉: multi level queue는 사용자 친화적인 프로세스를 foreground, 사용자와 상호작용하지 않는 프로세스를 background 큐에 넣어 CPU 제어를 관리합니다. Foreground 큐가 우선시되기 때문에 Starvation 문제가 발생할 수 있으므로 큐마다 적절한 CPU 시간을 할당해야합니다. 이를 구체적으로 사용한 예시가 Multilevel feedback queue입니다. Multilevel feedback queue는 해당 프로세스가 기준 시간 안에 작업을 완료하지 못한 경우 하위 레벨의 큐로 떨어져 우선순위를 점점 낮우는 방식을 사용합니다.
* 이미현: multilevel queue는 ready queue 를 여러개로 분할하고, 각각의 queue의 우선순위를 정해서 각 프로세스를 우선순위에 따라 queue에 배치하고, queue간 경쟁을 통해 하나의 queue가 cpu를 점유하는 형태입니다. queue간의 점유 시간 격차가 크면 클수록 기아현상이 일어날 가능성이 높으므로, time slice를 통해 각 queue의 CPU time을 적절하게 할당해야 합니다.

​         

### 사용자 프로그램이 사용하는 함수 3가지

- 이주형

  > - 사용자 정의 함수
  > - 라이브러리 함수
  >   - 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
  >   - 자신의 프로그램 실행 파일에 포함되어 있다
  > - 커널 함수
  >   - 운영체제 프로그램의 함수
  >   - 커널 함수의 호출 = 시스템
  >   - 커널의 코드에 포함

​         

### 프로세스가 생성(new)되어 종료(terminated)될때까지의 프로세스 상태 변화에 대해 설명하시오.

* 앙요셉: 메모리에 올라온 프로세스는 CPU를 사용하기 위해 Ready queue에 들어갑니다. 차례가 되면 CPU에서 실행하는데 이를 Running 상태라고 합니다. 중간에 I/O작업을 처리하는 경우 Blocked 상태가 되며 타이머에 Interrupt되는 경우 기존 수행 데이터는 Swap area에 suspend되고 프로세는 다시 Ready Queue 대기열 맨 뒤로 이동합니다. 작업을 모두 완료하는 경우 모든 자원을 반납하고 종료합니다.

* 이주형

  > - 자발적 종료
  >   - 마지막 statement 수행 후 exit() 시스템 콜을 통해
  >   - 자식이 부모에게 output data를 보냄 (via wait)
  >   - 프로세스의 각종 자원들이 운영체제에게 반납됨
  >   - 프로그램에 명시적으로 적어주지 않아도 main함수가 리턴되는 위치에 컴파일러가 넣어줌
  > - 비자발적 종료
  >   - 부모 프로세스가 자식 프로세스를 강제 종료시킴 (abort)
  >     - 자식 프로세스가 한계치를 넘어서는 자원 요청
  >     - 자식에게 할당된 태스크가 더 이상 필요하지 않은 경우
  >   - 키보드로 kill, break를 친 경우
  >   - 부모가 종료하는 경우 자식들이 먼저 종료

* 이미현: 프로세스 생성 후 CPU 를 기다리는 Ready 상태로 변경되고, CPU를 할당받으면 Running 상태가 됩니다. I/O 등의 event 에 의해 CPU 가 당장 instruction을 수행할 수 없는 상태가 되면 blocked(waiting) 상태로 변경되고, event 가 종료되면 다시 ready 상태가 됩니다.

​                       

### 스케줄링 알고리즘 중 SJF의 두가지 방법에 대해 설명하고 장점

* 이주형

  > - Nonpreemptive : 일단 프로세스가 진행되면 남은 시간보다 더 짧은 CPU burst time을 가진 프로세스가 들어와도 실행 중이던 프로세스를 종료 후 다음 프로세스를 진행
  > - Preemptive : 남은 시간보다 짧은 CPU burst time을 가진 프로세스가 들어오면 바로 context switch(SRTF- Shortest Remaining Time First)
  > - 평균 waiting time이 가장 적다

​        

### RoundRobin 방식에서 할당 시간을 정하는 기준은?

* 양요셉: (SJF는 평균대기시간을 최소화할 수 있지만 Starvation 문제가 발생할 수 있다는 문제점이 있습니다.) RR방식은 프로세스마다 CPU를 형평성 있게 사용하도록 합니다. 그래서 Starvation 문제 등 기복없이 프로세스 작업을 처리할 수 있다는 장점이 있습니다. 프로세스의 작업은 I/O나 CPU 사용이 치우친 경우가 많은데 이런 상황에서 좋은 효율을 낼 수 있습니다.
* 이주형: I/O bound job은 바로 처리되서 나가고 CPU bound job은 적절히 처리되고 나갈 정도의 시간으로 정해야 한다. 너무 짧으면 overhead가 커진다
* 이미현: 라운드로빈은 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간 단위로 CPU 를 할당하는 방식의 CPU 스케줄링 알고리즘 입니다. 시간 간격이 작을 경우 context switching 의 오버헤드가 커지고, 시간 간격을 무한히 크게 할 경우 들어오는 순서대로 처리하므로 FIFO 와 같은 방식으로 처리됩니다.

* 정성우: context switch의 오버헤드 와 들어온 프로세스의 대기시간을 기준으로 정해집니다.

​        

### 스케줄링 알고리즘 중 SJF

* 양요셉: Shortest Job First 작업은 CPU 이용 시간이 짧은 프로세스를 우선적으로 처리해 전체 프로세스의 평균 대기시간을 최소화할 수 있는 방식입니다. 하지만 CPU작업시간이 매우 긴 프로세스는 제어권을 받지 못하는 Starvation문제가 발생할 수 있습니다. 이에 대비하여 Aging방식을 통해 시간이 흐를수록 우선순위에 가중치를 부여하는 등 방식을 생각해볼 수 있습니다.
* 이미현: Shortest Job First. 평균 대기시간을 최소화 하기 위해 CPU 점유시간이 가장 짧은 프로세스에 CPU 를 먼저 할당하는 방식입니다. 실행 시간이 긴 프로세스는 starvation 문제가 발생할 수 있습니다.

​       

### Modebit의 역할은 무엇인가요? 그리고 어떤 방식으로 작동하나요?

* 양요셉: Mode Bit은 이중 동작 모드(Dual-mode-Operation)에서 사용하는 방식입니다. 사용자의 프로그램이 잘못된 수행으로 (메모리 자원을 망가뜨려) 운영체제에 피해를 줄 수 있는데 이에 대한 보호 장치로 Mode bit를 사용합니다. 프로그램의 기본 모드 비트는 1이며 user 모드라고 부릅니다. 프로그램은 시스템 콜을 통해 monitor mode(모드 비트가 0)로 변경해 특권 명령을 사용할 수 있습니다.
* 이미현: 사용자와 OS는 시스템 자원을 공유하기 때문에 OS 의 안전과 적절한 동작을 위해서 보호장치가 필요합니다. 이때 하드웨어에서 직접 제공해주는 기능인 mode bit 이 쓰입니다. 사용자가 수행하는 코드와 OS가 수행하는 코드를 나누고 이 두 연산을 사용자 모드와 커널모드로 구분합니다. mode bit이 1인 경우, 사용자모드라고 하며 사용자 수준의 코드를 수행하고, mode bit 가 0인 경우, 커널모드라고 하며 OS 코드가 수행됩니다.

​         

### 장기 스케줄러와, 중기 스케줄러의 차이는?

* 양요셉: 장기 스케줄러는 프로세스는 new에서 Ready 상태로 바꿔주는 역할을 합니다. 즉 메모리를 부여하는 역할을 합니다. 일반적인 운영체제에서는 사용하지 않는 방식입니다. 중기 스케줄러는 프로세스에게서 Memory를 빼앗는 방식입니다. 빼앗긴 프로세스는 Swap Area로 이동합니다.
* 이미현: 장기 스케줄러는 어떤 프로세스가 시스템의 자원을 차지할 것인지를 결정합니다. 중기 스케줄러는 swapper라고도 부르며, 메모리에 올라간 프로세스의 일부를 잠시 내렸다가 올리는 (swap-in, swap-out) 작업을 통해 CPU 성능을 높인다.

​      

### 프로세스의 생명 주기에서 suspended의 특징

* 양요셉: 외부적인 이유로 프로세스가 정지된 상태입니다. block은 자신이 요청한 작업이 완료되면 다시 Ready 상태로 되지만 Suspend는 외부에서 resume 해주어야 Active한 상태가 될 수 있습니다.
* 이미현: 특정한 이유로 프로세스의 수행이 정지된 상태를 의미하며, 외부에서 재개시키지 않는 이상 다시 활성화 될 수 없습니다.

​       

### 인터럽트란?

* 양요셉: CPU에 인터럽트가 발생하면 CPU가 관리하고 있는 프로세스의 레지스터와 program counter는 저장되고 인터럽트 처리루틴을 따릅니다. 하드웨어가 발생시킬 수도 있지만 프로그램이 OS에 요청해 인터럽트를 발생시킬 수 있는데 이를 Trap이라고 합니다. 시스템콜을 통해 커널함수를 호출하거나 예외를 발생시키는 경우 트랩이 발생했다고 합니다.
* 이미현: CPU 가 프로그램을 실행하고 있을 때, 예외 상황이 발생하여 처리가 필요한 경우 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말합니다. 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉩니다. 하드웨어 인터럽트는 하드웨어 장치에 의해 발생하고, 소프트웨어 인터럽트는 소프트웨어에서 예외상황이나 system call 에 의해 발생합니다.

* 정성우: 프로세스가 CPU를 할당 받게되면 다른 프로세스(운영체제를 포함한)들이 CPU를 뺏어 올 수 없는데 하드웨어적으로 CPU를 뺏어오는 신호가 인터럽트 입니다.

​       

### PCB 에 대해 설명하고 PCB 구성요소에 대해서 3가지 이상 예를 드시오.

* 양요셉: PCB는 프로세스 제어블록입니다. 운영체제의 입장에서 프로세스 스케줄링을 위해 프로세스의 관한 데이터를 PCB에 저장합니다. 문맥 교환이 일어나기 전 수행하던 작업들의 진행 상황을 PCB에 저장해 다음 작업을 원활히 수행하도록 할 수 있습니다. PCB에는 CPU가 관리하는 하드웨어 값인 Program counter와 register가 있고 메모리 관련한 code,data,stack 부분이 있습니다. 이 외에 다른 부분이 있지만 이름까지 자세히 기억나지는 않습니다.
* 이미현: 프로세스 관리에 필요한 정보들을 포함하는 운영체제 커널의 자료구조입니다. PID, Process state, PC(Program Counter), CPU 레지스터 및 일반 레지스터 등이 있습니다.

​        

### fork 의 동작에 대해 설명하시오

* 양요셉: 부모프로세스가 특정 작업을 수행하기 위해 자식 프로세스를 생성할 때 fork를 사용합니다. 이 때 자식의 PID값은 0으로 부모와 다른 작업을 수행하고 부모 프로세스는 보통 wait 상태로 됩니다.
* 이미현: fork 가 실행되면 부모프로세스의 모든 데이터를 복제한 자식프로세스가 생성되어 실행됩니다. 이 때 자식 프로세스의 pid는 0입니다. 자식프로세스는 부모와 똑같이 fork() 다음 코드부터 실행합니다.

​       

### 스레드 간 통신보다 프로세스 간 통신이 어려운 이유?

* 양요셉: 스레드는 같은 프로세스 안에서 Programcounter, register, stack의 고유 공간을 제외하고 서로의 데이터를 공유하기 때문에 서로 간 통신을 원활하게 할 수 있습니다. 하지만 프로세스간 통신을 위해 Message Passing이나 프로세스 자원을 공유해야하는데 커널의 도움을 필요로 합니다. 이에 스레드 간 통신보다 프로세스 간 통신의 오버헤드가 더 커집니다.
* 이미현: 프로세스는 생성되면서 PC를 포함하여 메모리 공간을 위해 별도의 자원을 할당하지만, 스레드는 메모리 공간과 자원을 공유하기 때문에 스레드간 통신이 더 수월합니다. 프로세스간 통신을 위해서는 통신을 위한 별도의 공간을 만들어주어야 합니다.

​         

​          



## < 기말 범위 >    

> 기말 범위의 질문들

### 데드락이란 무엇인가?

* 양요셉: 프로세스들이 서로가 가진 자원을 기다리며 무한정 block 되는 상태를 말합니다. 데드락은 Mutual exclusion(상호 배제), No preemption(비선점), Hold and Wait(점유와 대기), Circular wait(환형 대기) 를 모두 만족했을 때 발생합니다.
* 이주형: 교착상태. 프로세스들이 서로가 가진 자원을 기다리며 block 되어있는 상태를 말한다. 데드락은 Mutual exclusion(상호 배제), No preemption(비선점), Hold and Wait(점유와 대기), Circular wait(환형 대기) 를 모두 만족해야 발생한다.
* 이미현: 교착상태. 프로세스들이 서로가 가진 자원을 기다리며 block 되어있는 상태를 말합니다. 데드락은 Mutual exclusion(상호 배제), No preemption(비선점), Hold and Wait(점유와 대기), Circular wait(환형 대기) 를 모두 만족해야 발생합니다.

* 정성우: 프로세스들이 서로가 가진 자원을 무한정 기다리는 상태를 의미합니다

​     

### MMU란 무엇인가?

* 양요셉: Memory Management Unit 의 약자로, 논리적 주소를 물리적 주소로 변환해주는 하드웨어 장치입니다. MMU에는 물리적 메모리 주소의 시작값을 담고 있는 Relocation register와 범위를 저장하는 Limit register가 있습니다. 범위를 벗어나면 인터럽트가 발생해 프로세스의 주소 할당을 중지합니다. MMU를 통해 Runtime Binding을 실현할 수 있습니다.
* 이주형: Memory Management Unit 의 약자로, 논리적 주소를 물리적 주소로 매핑해주는 Hardware device 이다. MMU에는 접근할 수 있는 물리적 메모리 주소의 최소값(시작값) 을 저장하는 Relocation register와 논리적 주소의 범위를 저장하는 Limit register가 있다.
* 이미현: Memory Management Unit 의 약자로, 논리적 주소를 물리적 주소로 매핑해주는 Hardware device 입니다. MMU에는 접근할 수 있는 물리적 메모리 주소의 최소값(시작값) 을 저장하는 Relocation register와 논리적 주소의 범위를 저장하는 Limit register가 있습니다.

​     

### 스케줄링의 성능척도 5가지를 말해보세요

> - CPU utilization(이용률)
> - Throughput(처리량)
> - Turnaround time(소요시간)
> - Waiting time(대기시간)
> - Response time(응답시간)

​        

### race condition 이란 무엇인가? 이로인해 생길 수 있는 문제는?

* 양요셉: 여러 프로세스들이 동시에 공유 데이터를 접근하면서 발생할 수 있는 문제들을 말합니다. Critical section에서 변수값이 달라진다면 데이터 불일치 문제로 비정상 작동할 수 있습니다.이를 해결하기 위해 동시 수행되는 프로세스 (concurrent process) 들은 모두 동기화 되어야 합니다.
* 이주형: 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황. 데이터의 불일치 문제를 발생시킬 수 있다. 데이터의 일관성 유지를 위해서 동시 수행되는 프로세스 (concurrent process) 들은 동기화 되어야 한다.
* 이미현: 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황. 데이터의 불일치 문제를 발생시킬 수 있습니다. 데이터의 일관성 유지를 위해서 동시 수행되는 프로세스 (concurrent process) 들은 동기화 되어야 합니다.

​       

### clock algorithm이란?

* 양요셉: paging system이 실제로 사용하는 page replacement Algorithm으로 원형 queue를 순회하면서 어떤 프로그램을 Page fault할지 결정하는 알고리즘입니다. 포인터가 한바퀴 돌 때까지 한 번이라도 참조되었다면 reference bit는 1로 변환되고 포인터가 지나갈 때 1을 0으로 바꿉니다. 포인터가 지나갈 때 bit값이 0인 상태라면 그 페이지를 swap area로 이동하고 CPU가 요청한 페이지를 메모리에 올립니다.
* 이주형: paging system이 실제로 사용하는 page replacement Algorithm으로 원형 queue와 reference bit을 사용하여 교체 대상 페이지를 선정하는 알고리즘이다. 포인터가 이동하는 중 reference bit 1은 모두 0으로 바꾸고 한 바퀴를 돌때까지 페이지가 참조되지 않으면 0 그래도인 상태로 그 페이지를 교체한다.
* 이미현: 실제 시스템에서 page 교체를 위해 사용되는 알고리즘으로, 원형 queue와 reference bit을 사용하여 교체 대상 page를 선정하는 알고리즘입니다. reference bit가 1인 경우 최근에 사용된 페이지, 0일 경우 최근에 사용되지 않은 페이지로 reference bit 가 0인 frame을 만나면 해당 frame의 페이지를 쫓아냅니다.

​       

### 내부조각과 외부조각

* 양요셉: 내부 조각은 프로그램에 메모리가 배정되었을 때 프로그램이 사용하지 않는 공간을 뜻합니다. 반면 외부조각은 메모리에 배정된 프로그램 사이 다른 프로그램이 들어갈 수 없는 공간을 말합니다. 외부조각 문제를 해결하기 위해 Paging기법과 Segmentation 기법을 사용합니다.

* 이주형

  >Internal fragmentation(내부 조각) : 
  >
  >- 프로그램 크기보다 분할의 크기가 큰 경우
  >- 하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각
  >- 특정 프로그램에 배정되었지만 사용되지 않는 공간
  >
  >External fragmentation(외부 조각) :
  >
  >- 프로그램 크기보다 분할의 크기가 작은 경우
  >- 아무 프로그램에도 배정되지 않은 빈 곳인데도 프로그램이 올라갈 수 없는 작은 분할

* 이미현: 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 프로세스에서 사용하는 메모리 공간이 낭비되는 상황을 내부 단편화이라고 하고, 메모리가 할당되고 해제되는 작업이 반복될 때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황을 외부 단편화 라고 합니다.

​         

### Processor-Consumer Problem

- 앙요셉: 버퍼에 있는 공유 자원을 사용할 때 생산자 프로세스나 소비자 프로세스가 동시에 도착하면 같은 공유데이터를 참조하면서 문제가 발생합니다. 이를 방지하기 위해 접근 시 미리 lock을 걸고 자원을 획득하거나 저장하는 방식을 사용할 수 있고 Semaphor와 큐를 활용한 Monitor 구조를 사용할 수도 있습니다.
- 이주형: 발생할 수 있는 문제: 두 개의 생산자 프로세스가 동시에 도착하면 하나의 비어있는 버퍼에 동시에 두 개의 데이터를 집어 넣으면 문제 발생. 때문에 빈 버퍼에 데이터를 넣는 작업을 그냥 하지 않고 공유 데이터에 lock을 걸어서 다른 프로세스들의 접근을 막은 다음 비어있는 버퍼에 데이터를 집어넣고, 데이터를 집어넣는 작업이 끝나면 lock을 풀어서 다른 생산자 프로세스 혹은 소비자 프로세스가 공유 버퍼에 접근할 수 있게 해줌.
- 이미현: 여러 개의 프로세스를 어떻게 동기화할 것인가에 관한 고전적인 문제로 bounded buffer problem 이라고도 합니다. 유한한 개수의 데이터를 임시로 보관하는 버퍼에 여러개의 생산자와 소비자 프로세스가 접근합니다. 생산자는 데이터를 저장할 때, 저장할 공간이 없는 문제가 발생할 수 있고, 소비자는 데이터가 필요할때 가져올 데이터가 없는 문제가 발생할 수 있습니다. 
  counting semaphore를 이용하여 남은 버퍼의 갯수를 세고, binary semaphore를 이용하여 공유버퍼의 lock 을 걸고 풀는 동작을 통해 문제를 해결할 수 있습니다.

​             

###  TLB의 핵심 기능과 보완할 부분

* 양요셉: TLB는 캐싱 기법을 사용해 메모리에 직접 접근하지 않고 자주 사용하는 페이지를 탐색할 수 있도록 합니다. 하지만 index가 없기 때문에 하나씩 탐색해야하는 단점이 존재하며 associative register을 사용해 병렬적인 탐색을 통해 극복할 수 있습니다.

* 이미현: TLB는 주소 변환을 빠르게 하기 위한 일종의 cache memory입니다. TLB는 논리적인 페이지 번호와 물리적인 페이지 번호 두가지의 값을 저장하고 있어야 하는데, 바로 논리적인 주소로 offset 접근을 할 수 있는 것이 아니라 TLB 전체를 모두 검색해봐야 한다는 문제점이 존재합니다. 따라서 associative register 를 이용하여 parallel search 를 통해 전체를 한번에 검색해서 시간복잡도를 낮출 수 있습니다.

  ​     

### 주소바인딩 방식들은 어떻게 분류되고 차이점은 무엇인가?

* 양요셉: complie time binding은 absolute 한 주소로 새로 로드되도 주소는 여전히 그대로입니다. Load time binding: Loader 책임 하에 로드할 때마다 주소 변경가능하고 Runtime binding은 MMU의 도움으로 프로그램 실행 중에도 주소를 변경할 수 있습니다.
* 이미현: Compile time binding/Load time binding/Run time binding 으로 분류됩니다. Compile time binding 은 컴파일시 바인딩하는 방식으로 비효율적이며 현대 운영체제에 적합하지 않은 방식입니다. Load time binding 은 프로그램이 실행되는 시점에 바인딩되는 방식으로 Loader의 책임하에 물리적 메모리 주소를 부여합니다. Runtime binding 은 하드웨어적인 지원이 필요한 방식으로 실행 중에도 주소 변경이 가능한 방법입니다.

​      

### Segmentation의 Paging 기법과 비교한 장점과 단점은?

* 양요셉: 일정 크기로 자르는 Paging기법과는 달리 Segmentation은 문맥 단위로 잘라서 메모리에 배분합니다. 내부조각은 생기지 않지만 외부조각이 생길 수 있으며 구현이 복잡하다는 단점이 있습니다.
* 이미현: Segmentation은  일정한 크기로 나누는 paging 기법과 다르게 의미단위인 segment로 프로그램을 구성합니다. 의미 단위이기 때문에 공유와 보안에 있어 paging 기법보다 훨씬 효과적이지만, 외부조각이 발생할 수 있다는 문제점이 있습니다.

* 정성우: 일정한 크기로 나눠 관리하는 paging기법에서는 프로세스 크기가 페이지 보다 작으면 내부 단편화가 생기는데 반해 segmentation에서는 문맥 단위로 관리하기때문에 내부 단편화가 생기지 않습니다 하지만 블록의 크기가 각각 다르기때문에 외부 단편화가 생길 수 있을뿐만 아니라 구현이 복잡하다는 점이 있습니다.

​          

| 키워드              | 단원                           | 설명                                                 | 관련키워드                                       |
| ------------------- | ------------------------------ | ---------------------------------------------------- | ------------------------------------------------ |
| interupt                              | 2. 컴퓨터시스템의 구조 | OS에게 cpu를 양도하라는 일종의 신호, 주로 HW관점의 인터럽트를 의미 | trap<br /> 시스템 콜<br /> 모드비트<br /> Exception          |
| registers                             | 2. 컴퓨터시스템의 구조 | 프로세서가 접근할 수 있는 가장 가까운 영역의 기억장치        | program counter<br /> cahce<br /> buffers                    |
| DMA                                   | 2. 컴퓨터시스템의 구조 | CPU이외의 HW가 CPU의 허가없이 디바이스 컨트롤러의 버퍼내용을 메모리에 block단위로 직접 전송하는 개념 |                                                              |
| program                               | 03. 프로세스 관리      | 어떤 문제를 해결하기위한 명령어와 명령어의 순서, 자료들의 집합 | context switch<br /> process<br /> PCB                       |
| Blocked 상태                          | 03. 프로세스 관리      | 모종의 이유로 CPU를 할당 받아도 당장 일을 시작 할 수 없는 상태(단 메모리상에 load된 상태)논리적, 물리적 실체에 대응되는 주소공간<br /> 실제 물리적 공간이 아님 | Suspended 상태                                               |
| Scheduler                             | 03. 프로세스 관리      | OS에서 스케줄링을 담당하는 코드                              | job-job-scheduler<br /> CPU-scheduler<br /> swapper          |
| Thread                                | 03. 프로세스 관리      | 프로세스의 CPU 수행 단위<br /> 주소공간에서 data, code는 공유 stack 각각의 thread의 정보를 저장<br /> PCB에선 PC와 레지스터를 제외한 부분은 공유 | code 영역<br /> data 영역<br /> stack 영역                   |
| IPC                                   | 04. CPU 스케줄링       | Interprocess Communication 프로세스간 협력 메커니즘          | 독립 프로세스<br /> 협력 프로세스<br /> 메시지 패싱<br /> 메모리 공유<br /> Thread |
| CPU 스케줄링 알고리즘                 | 04. CPU 스케줄링       |                                                              | FCFS<br /> SJF<br />SRTF<br /> Priority Scheduling<br /> RR<br />  Multilevel Queue <br /> Multilevel Feedback Queue |
| Race Condition                        | 05. 병행제어           | 경쟁상태 저장공간을 공유하는 프로세서가 여럿 있는경우 프로세스의 저장공간 접근 타이밍이나 순서등이 결과값에 영향을 줄 수 있는 상태 | critical-section<br /> semaphores<br /> starvation<br /> Monitor |
| 병행제어의 여러 문제들                | 05. 병행제어           |                                                              | producer-consumer problem<br /> readers-writers problem<br /> 식사하는 철학자 |
| deadlock                              | 06. 데드락             | 프로세스들이 서로가 가진 자원을 무한정 기다리는 상태         | mutual exclusion<br /> no preemption<br /> hold and wait<br /> circular wait |
| 주소 바인딩                           | 07. 메모리 관리        | 물리적 주소에 논리적 주소를 매핑하는 과정                    | compile time binding<br /> load time binding<br /> run time binding<br /> MMU |
| 메모리 관리                           | 07. 메모리 관리        |                                                              | Dynamic Loading<br /> Dynamic Linking<br /> Overlays<br /> Swapping |
| Hole                                  | 07. 메모리 관리        |   할당 되지 않은 남은 메모리 영역                     | 외부조각<br /> 내부조각                                      |
| Noncotiguous allocation (불연속 할당) | 07. 메모리 관리        | 가상 메모리의 내용을 연속된 형태가 아닌 조각으로 나뉘어 load를 하는 방식 | Paging<br /> Segmentation<br /> table<br /> TLB              |
| 페이지 교체 알고리즘                  | 08. 가상메모리         | 페이지 폴트가 났을때 페이지 캐시에서 제외할 페이지를 선정하는 알고리즘               | FIFO<br /> Optimal Replacement<br />LRU<br />  LFU<br /> Clock |
| Thrashing                             | 08. 가상메모리         | 프로세스 수행시간 보다 페이지 교체시간이 많아질때 처리속도가 떨어지는 상태 | PFF<br /> working set                                        |
| File                                  | 09. 파일 시스템        | 관련있는 정보들을 이름을 가지고 모아둔것                     | File system<br /> metadata<br /> Mounting<br /> Directory<br /> Partition |
| cache                                 | 09. 파일 시스템        |                                                              | Page Cache <br /> Buffer Cache                               |
| 디스크 스케줄링                       |                        | 가장 오래걸리는 헤드의 이동시간 Seek time을 최소화 하기위한 목적 | FCFS<br /> SCAN <br /> Look                                  |

