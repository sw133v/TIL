# Multiple-processor scheduling



* cpu가 여러개인 경우 스케줄링은 더욱 복잡해짐

* Homogeneous processor 인경우

  * 큐에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다
  * 반드시 특정 프로세서에서 수행되어야 하는 스포레스가 있는 경우에는 문제가 더 복잡해짐

* Load sharing

  * 일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요
  * 별개의 큐를 두는 방버 vs. 공동 큐를 사용하는 방법

* Symmetric Multiprocessing(SMP)

  * 각 프로세서가 각자 알아서 스케줄링 결정

* Asymmetric multiprocessing

  * 하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름

   

## thread scheduling

* #### local scheduling

> User level thread의 경우 사용자 수준의 thread library에 의해 어떤
>
> thread를 스케줄 할지 결정

* #### Global scheduling

> Kernel level thread의 경우 일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤
>
> thread를 스케줄 할지 결정



* ## Process Sinchronization



#### 데이터 접근

| Execution-Box | Strage-Box              |
| ------------- | ----------------------- |
| 1)CPU         | Memory                  |
| 2)컴퓨터 내부 | 디스크                  |
| 3)프로세스    | 그 프로세스의 주소 공간 |

#### Race Condition(경쟁 상태)

S-box를 공유하는 E-box가 여럿 있는 겨웅 Race Condition의 가능성이 있음

| s-box          | e-box   | 비고                                                         |
| -------------- | ------- | ------------------------------------------------------------ |
| Memory         | CPU     | Multiprocessor system                                        |
| Addredss Space | Process | 공유 메모리를 사용하는 프로세스들, 커널 내부 데이터를 접근하는 루틴들 간(ex: 커널모드 수행 중 인터럽트로 커널모드 다른 루틴 실행시) |



그러나 S-box가 하나인 상태에서도 발생 가능 : 위 표의 2번째 상황이 그 예 



#### OS에서 경쟁상태 발생경우

* 커널모드로 수행중 인터럽트 발생시
  * 해결책1 : 인터럽트를 특정구간에서 받고 안받고를 설정 -> 한번에 하나의 cpu만이 커널에 들어보내는것
  * 해결책2 : 커널 내부에 있는 각 공유데이터에 접근할 떄마다 그 데이터에 대한 lock/unlock
* Process가 시스템콜을 하여 커널모드로 수행중인데 context switch가 일어나는 경우
  * 해결책 : 커널모드에서 수행중일때는 cpu를 빼앗지 않음, 커널모드가 아닌 사용자모드 에서cpu를  빼앗음
* Multiprocessor에서 공유 메모리 내의 커널 데이터



### Process Synchronization 문제

* 공유 데이터( shared data) 의 동시 접근(concurrent access)은 데이터의 불일치 문제(inconsistency)를

  발생시킬 수 있다

* 일관성(consistency)유지를 위해서는 협력 프로세스(cooperation process)간의 실행 순서(orderly execution)를 정해주는 메커니즘 필요
* 경쟁 상태를 막기 위해서는 협력프로세스는 동기화(snchronize)되어야 한다